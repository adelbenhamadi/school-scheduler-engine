unit ENGINE;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/10/2012                                            }
{    Generated Time: 07:13:50                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> c:\c-test-projects\emploi-lib\engine13\ENGINE.H <=}

{$INCLUDE <cstring>}
{$INCLUDE <ctime>}
{$INCLUDE "../solution.h"}
{$INCLUDE "../I_engine.h"}

{$IFNDEF EMENGINE_H}
{$DEFINE EMENGINE_H}


const
  ENGINENAME = 'ENGINE1-alpha31';
const
  ENGINE_DEBUGMODE_LEVEL = -1;

const
  ENGINE_ERROR_LOADING = 500;



var
  emEngine: function: Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ~emEngine: function: VIRTUAL cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  execute: procedure(_first: Bool; 
                     _new: Bool; 
                     hltx: Double; 
                     lltx: Double; 
                     mltx: Double) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  Release: function: Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  verifySolution: function(b: Bool): Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  getOptimizeValue: function(var hp: Integer; 
                             var hc: Integer; 
                             var cp: Integer; 
                             var cc: Integer): Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  Load: function(cf: PChar): Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  Save: function(const fn: PChar): Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  getPluginInfo: var function: CENGINEPLUGIN cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SeancesCount: function: Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  NextDay: function cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  initStartDay: procedure cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doFill: procedure cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doRandomize: procedure cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doSort: procedure(const ascendant: Bool) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doShellSort: procedure(const ascendant: Bool) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doQuickSort: procedure(const ascendant: Bool; 
                         const p: Integer; 
                         const r: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doPartition: function(const p: Integer; 
                        const r: Integer): Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  getProcessArrayChecksum: function: LongInt cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doCheck: function: Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  swapValues: procedure(const v: Integer; 
                        const w: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  moveIndex: function(i1: Integer; 
                      i2: Integer): Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  checkEmptyDT: function: Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  CheckIsEmpty: function: Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  RempliSalle: function(ABool=true: Bool): Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  Initialize: procedure(const AReset: Bool) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  Process: function: Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  StartSearching: function: Bool cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  doFillConstraintMap: procedure cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 


{///CDayTable* ProfDT,*SalleDT,*ClasseDT; }
{+// CSalle*curSalle; }
{-CProf*curProf; }
{-CMat*curMat; }
{=CClasse*curClasse; }





{$ENDIF // EMENGINE_H}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('ENGINE.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @emEngine := GetProcAddress(DLLHandle,'emEngine');
  {$IFDEF WIN32}
    Assert(@emEngine <> nil);
  {$ENDIF}
    @~emEngine := GetProcAddress(DLLHandle,'~emEngine');
  {$IFDEF WIN32}
    Assert(@~emEngine <> nil);
  {$ENDIF}
    @execute := GetProcAddress(DLLHandle,'execute');
  {$IFDEF WIN32}
    Assert(@execute <> nil);
  {$ENDIF}
    @Release := GetProcAddress(DLLHandle,'Release');
  {$IFDEF WIN32}
    Assert(@Release <> nil);
  {$ENDIF}
    @verifySolution := GetProcAddress(DLLHandle,'verifySolution');
  {$IFDEF WIN32}
    Assert(@verifySolution <> nil);
  {$ENDIF}
    @getOptimizeValue := GetProcAddress(DLLHandle,'getOptimizeValue');
  {$IFDEF WIN32}
    Assert(@getOptimizeValue <> nil);
  {$ENDIF}
    @Load := GetProcAddress(DLLHandle,'Load');
  {$IFDEF WIN32}
    Assert(@Load <> nil);
  {$ENDIF}
    @Save := GetProcAddress(DLLHandle,'Save');
  {$IFDEF WIN32}
    Assert(@Save <> nil);
  {$ENDIF}
    @getPluginInfo := GetProcAddress(DLLHandle,'getPluginInfo');
  {$IFDEF WIN32}
    Assert(@getPluginInfo <> nil);
  {$ENDIF}
    @SeancesCount := GetProcAddress(DLLHandle,'SeancesCount');
  {$IFDEF WIN32}
    Assert(@SeancesCount <> nil);
  {$ENDIF}
    @NextDay := GetProcAddress(DLLHandle,'NextDay');
  {$IFDEF WIN32}
    Assert(@NextDay <> nil);
  {$ENDIF}
    @initStartDay := GetProcAddress(DLLHandle,'initStartDay');
  {$IFDEF WIN32}
    Assert(@initStartDay <> nil);
  {$ENDIF}
    @doFill := GetProcAddress(DLLHandle,'doFill');
  {$IFDEF WIN32}
    Assert(@doFill <> nil);
  {$ENDIF}
    @doRandomize := GetProcAddress(DLLHandle,'doRandomize');
  {$IFDEF WIN32}
    Assert(@doRandomize <> nil);
  {$ENDIF}
    @doSort := GetProcAddress(DLLHandle,'doSort');
  {$IFDEF WIN32}
    Assert(@doSort <> nil);
  {$ENDIF}
    @doShellSort := GetProcAddress(DLLHandle,'doShellSort');
  {$IFDEF WIN32}
    Assert(@doShellSort <> nil);
  {$ENDIF}
    @doQuickSort := GetProcAddress(DLLHandle,'doQuickSort');
  {$IFDEF WIN32}
    Assert(@doQuickSort <> nil);
  {$ENDIF}
    @doPartition := GetProcAddress(DLLHandle,'doPartition');
  {$IFDEF WIN32}
    Assert(@doPartition <> nil);
  {$ENDIF}
    @getProcessArrayChecksum := GetProcAddress(DLLHandle,'getProcessArrayChecksum');
  {$IFDEF WIN32}
    Assert(@getProcessArrayChecksum <> nil);
  {$ENDIF}
    @doCheck := GetProcAddress(DLLHandle,'doCheck');
  {$IFDEF WIN32}
    Assert(@doCheck <> nil);
  {$ENDIF}
    @swapValues := GetProcAddress(DLLHandle,'swapValues');
  {$IFDEF WIN32}
    Assert(@swapValues <> nil);
  {$ENDIF}
    @moveIndex := GetProcAddress(DLLHandle,'moveIndex');
  {$IFDEF WIN32}
    Assert(@moveIndex <> nil);
  {$ENDIF}
    @checkEmptyDT := GetProcAddress(DLLHandle,'checkEmptyDT');
  {$IFDEF WIN32}
    Assert(@checkEmptyDT <> nil);
  {$ENDIF}
    @CheckIsEmpty := GetProcAddress(DLLHandle,'CheckIsEmpty');
  {$IFDEF WIN32}
    Assert(@CheckIsEmpty <> nil);
  {$ENDIF}
    @RempliSalle := GetProcAddress(DLLHandle,'RempliSalle');
  {$IFDEF WIN32}
    Assert(@RempliSalle <> nil);
  {$ENDIF}
    @Initialize := GetProcAddress(DLLHandle,'Initialize');
  {$IFDEF WIN32}
    Assert(@Initialize <> nil);
  {$ENDIF}
    @Process := GetProcAddress(DLLHandle,'Process');
  {$IFDEF WIN32}
    Assert(@Process <> nil);
  {$ENDIF}
    @StartSearching := GetProcAddress(DLLHandle,'StartSearching');
  {$IFDEF WIN32}
    Assert(@StartSearching <> nil);
  {$ENDIF}
    @doFillConstraintMap := GetProcAddress(DLLHandle,'doFillConstraintMap');
  {$IFDEF WIN32}
    Assert(@doFillConstraintMap <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: ENGINE.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
